# Bob Diet Coach - Remaining Features Implementation Plan

## Overview
This document outlines the remaining features to implement for Bob Diet Coach v2 (Convex Agent implementation). The core functionality is complete (~85%), and these features will bring us to 100% of the original vision.

## 1. Photo Analysis Feature ðŸ“¸ [PRIORITY: HIGH]

### Description
Enable users to upload food photos for AI-powered calorie and macro estimation.

### Requirements
- Free tier: 2 photo analyses per day
- Pro tier: Unlimited analyses
- Use Claude Vision API for analysis
- Store photo metadata (not the actual image)

### Implementation Steps

#### 1.1 Add Schema
```typescript
// In convex/schema.ts
photoAnalyses: defineTable({
  userId: v.string(),
  timestamp: v.number(),
  imageUrl: v.string(), // Temporary URL from upload
  analysis: v.object({
    foods: v.array(v.object({
      name: v.string(),
      calories: v.number(),
      protein: v.number(),
      carbs: v.number(),
      fat: v.number(),
      confidence: v.enum(["low", "medium", "high"])
    })),
    totalCalories: v.number(),
    overallConfidence: v.enum(["low", "medium", "high"])
  }),
  confirmed: v.boolean(),
  loggedFoodId: v.optional(v.id("foodLogs"))
}).index("by_user_date", ["userId", "timestamp"])
```

#### 1.2 Add Tool to Bob Agent with Vector Search
```javascript
// In convex/bobAgent.ts
export const analyzePhoto = createTool({
  description: "Analyze a food photo to estimate calories and macros",
  args: z.object({
    imageUrl: z.string(),
    mealContext: z.string().optional().describe("Any context about the meal")
  }),
  handler: async (ctx, args): Promise<object> => {
    // Check usage limits
    const usage = await ctx.runQuery(internal.usage.getPhotoUsageToday, {
      userId: ctx.userId
    });
    
    const userProfile = await ctx.runQuery(internal.users.getProfile, {
      userId: ctx.userId
    });
    
    if (!userProfile.isPro && usage >= 2) {
      return {
        error: true,
        message: "You've reached your daily photo analysis limit (2/2). Upgrade to Pro for unlimited analyses!"
      };
    }
    
    // Call Claude Vision API for analysis
    const analysis = await ctx.runAction(internal.vision.analyzeFood, {
      imageUrl: args.imageUrl,
      context: args.mealContext
    });
    
    // Generate embedding from photo metadata
    const metadataText = `${analysis.metadata.visualDescription} ${analysis.metadata.platingStyle} ${analysis.metadata.portionSize}`;
    const embedding = await ctx.runAction(internal.embeddings.generate, {
      text: metadataText
    });
    
    // Search for similar past photos
    const similarPhotos = await ctx.runQuery(internal.photos.searchSimilar, {
      userId: ctx.userId,
      embedding: embedding,
      limit: 3
    });
    
    // Enhance analysis with historical data
    if (similarPhotos.length > 0) {
      const avgCalories = average(similarPhotos.map(p => p.analysis.totalCalories));
      const confidence = analysis.confidence === "low" && 
                        Math.abs(avgCalories - analysis.totalCalories) < 100 
                        ? "medium" : analysis.confidence;
      
      analysis.enhancedEstimate = {
        historicalAverage: avgCalories,
        similarMealsFound: similarPhotos.length,
        adjustedConfidence: confidence,
        suggestion: `Based on your past similar meals, this is likely ${Math.round(avgCalories)} calories`
      };
    }
    
    // Save analysis with embedding
    const photoId = await ctx.runMutation(internal.photos.saveAnalysis, {
      userId: ctx.userId,
      imageUrl: args.imageUrl,
      analysis,
      embedding
    });
    
    // Track usage
    await ctx.runMutation(internal.usage.incrementPhotoUsage, {
      userId: ctx.userId
    });
    
    return {
      foods: analysis.foods,
      totalCalories: analysis.enhancedEstimate?.historicalAverage || analysis.totalCalories,
      confidence: analysis.enhancedEstimate?.adjustedConfidence || analysis.overallConfidence,
      similarMealsFound: similarPhotos.length,
      shouldConfirm: true,
      historicalContext: analysis.enhancedEstimate
    };
  }
});

// New tool for finding similar photos
export const findSimilarMeals = createTool({
  description: "Find similar meals from photo history",
  args: z.object({
    description: z.string().describe("Description of the meal to find")
  }),
  handler: async (ctx, args): Promise<object> => {
    // Generate embedding from description
    const embedding = await ctx.runAction(internal.embeddings.generate, {
      text: args.description
    });
    
    // Search photo history
    const similarPhotos = await ctx.runQuery(internal.photos.searchSimilar, {
      userId: ctx.userId,
      embedding: embedding,
      limit: 5
    });
    
    if (similarPhotos.length === 0) {
      return {
        found: false,
        message: "I haven't seen similar meals in your photo history yet."
      };
    }
    
    return {
      found: true,
      meals: similarPhotos.map(p => ({
        date: new Date(p.timestamp).toLocaleDateString(),
        description: p.metadata.visualDescription,
        calories: p.analysis.totalCalories,
        confidence: p.analysis.overallConfidence
      })),
      avgCalories: average(similarPhotos.map(p => p.analysis.totalCalories))
    };
  }
});
```

#### 1.3 Frontend Integration
- Add photo upload button in chat
- Handle image upload to temporary storage
- Display analysis results in a special card
- Allow confirmation flow similar to text food logging

## 2. Dynamic Metabolism Calibration ðŸŽ¯ [PRIORITY: HIGH]

### Description
Bob learns each user's actual metabolism using rolling averages, providing real-time calibration without waiting for predetermined intervals.

### Requirements
- Calculate moving averages for weight and calories
- Trigger calibration dynamically when sufficient data exists
- Provide insights as soon as patterns emerge
- Use existing calibrationHistory and weeklyAnalytics tables

### Implementation Steps

#### 2.1 Create Moving Average System
```typescript
// In convex/analytics.ts
export const updateMovingAverages = internalMutation({
  args: { userId: v.string() },
  handler: async (ctx, { userId }) => {
    // Calculate 7-day moving averages
    const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
    
    // Get weight data
    const weightLogs = await ctx.db.query("weightLogs")
      .withIndex("by_user_created", q => q
        .eq("userId", userId)
        .gte("createdAt", sevenDaysAgo))
      .collect();
    
    // Get food data
    const foodLogs = await ctx.db.query("foodLogs")
      .withIndex("by_user_date", q => q.eq("userId", userId))
      .filter(q => q.gte(q.field("createdAt"), sevenDaysAgo))
      .collect();
    
    if (weightLogs.length >= 3 && foodLogs.length >= 7) {
      const avgWeight = average(weightLogs.map(w => w.weight));
      const avgCalories = average(foodLogs.map(f => f.totalCalories));
      const avgProtein = average(foodLogs.map(f => f.totalProtein));
      
      // Store in userProfiles for quick access
      await ctx.db.patch(profile._id, {
        movingAverages: {
          weight7d: avgWeight,
          calories7d: avgCalories,
          protein7d: avgProtein,
          lastUpdated: Date.now()
        }
      });
      
      // Trigger calibration check
      await ctx.scheduler.runAfter(0, internal.calibration.checkForCalibration, { userId });
    }
  }
});
```

#### 2.2 Dynamic Calibration Trigger
```typescript
// In convex/calibration.ts
export const checkForCalibration = internalMutation({
  args: { userId: v.string() },
  handler: async (ctx, { userId }) => {
    const profile = await getUserProfile(ctx, userId);
    const movingAvgs = profile.movingAverages;
    
    // Need at least 14 days of data
    const twoWeeksAgo = Date.now() - 14 * 24 * 60 * 60 * 1000;
    const prevAvgs = await getPreviousAverages(ctx, userId, twoWeeksAgo);
    
    if (!prevAvgs || !movingAvgs) return;
    
    // Calculate weekly change from moving averages
    const weightChangeRate = (movingAvgs.weight7d - prevAvgs.weight7d) / 7; // kg per day
    const avgCalorieDeficit = profile.targetCalories - movingAvgs.calories7d;
    
    // Expected change (3500 cal deficit = 0.45 kg)
    const expectedChangeRate = (avgCalorieDeficit / 3500) * 0.45;
    
    // If significant discrepancy, calibrate
    const discrepancy = Math.abs(weightChangeRate - expectedChangeRate);
    
    if (discrepancy > 0.03) { // 30g/day difference
      const adjustment = (weightChangeRate - expectedChangeRate) * 7700; // cal per kg
      
      // Save to calibrationHistory (existing table)
      await ctx.db.insert("calibrationHistory", {
        userId,
        date: new Date().toISOString().split('T')[0],
        oldCalorieTarget: profile.targetCalories,
        newCalorieTarget: profile.targetCalories + Math.round(adjustment),
        reason: generateCalibrationReason(weightChangeRate, expectedChangeRate),
        dataPointsAnalyzed: 14,
        confidence: getConfidence(movingAvgs, prevAvgs),
        createdAt: Date.now()
      });
      
      // Update profile
      await ctx.db.patch(profile._id, {
        targetCalories: profile.targetCalories + Math.round(adjustment),
        lastCalibration: Date.now()
      });
      
      // Notify Bob to inform user
      await ctx.db.insert("systemMessages", {
        userId,
        type: "calibration_complete",
        adjustment: Math.round(adjustment)
      });
    }
  }
});
```

#### 2.3 Bob Integration
```javascript
// Add to bobAgent.ts
export const getCalibrationInsights = createTool({
  description: "Get metabolism calibration insights based on recent data",
  args: z.object({
    timeframe: z.enum(["recent", "all"]).default("recent")
  }),
  handler: async (ctx, args): Promise<object> => {
    const calibrations = await ctx.runQuery(internal.calibration.getUserCalibrations, {
      userId: ctx.userId,
      limit: args.timeframe === "recent" ? 1 : 5
    });
    
    if (calibrations.length === 0) {
      return {
        hasCalibration: false,
        message: "Still gathering data for your personalized calibration..."
      };
    }
    
    const latest = calibrations[0];
    return {
      hasCalibration: true,
      adjustment: latest.newCalorieTarget - latest.oldCalorieTarget,
      confidence: latest.confidence,
      reason: latest.reason,
      newTarget: latest.newCalorieTarget
    };
  }
});
```

#### 2.4 Continuous Updates
```javascript
// Trigger after each weight or food log
export const afterLogUpdate = internalMutation({
  args: { userId: v.string(), type: v.enum(["weight", "food"]) },
  handler: async (ctx, { userId, type }) => {
    // Update moving averages
    await ctx.scheduler.runAfter(0, internal.analytics.updateMovingAverages, { userId });
    
    // Update weekly analytics if it's Sunday
    const today = new Date().getDay();
    if (today === 0) {
      await ctx.scheduler.runAfter(0, internal.analytics.updateWeeklyAnalytics, { userId });
    }
  }
});
```

## 3. Advanced Pattern Recognition ðŸ§  [PRIORITY: MEDIUM]

### Description
Use vector search to find patterns in eating habits and their correlation with weight changes.

### Requirements
- Find foods that correlate with weight gain/loss
- Identify trigger foods
- Suggest successful meal patterns
- Weekly pattern reports

### Implementation Steps

#### 3.1 Pattern Analysis Tools
```javascript
// Add to bobAgent.ts
export const findPatterns = createTool({
  description: "Analyze user's eating patterns and their impact on weight",
  args: z.object({
    query: z.enum([
      "weight_gain_foods",
      "weight_loss_foods", 
      "bloating_triggers",
      "successful_days",
      "cheat_patterns"
    ]),
    timeframe: z.enum(["week", "month", "all"]).default("month")
  }),
  handler: async (ctx, args): Promise<object> => {
    const patterns = await ctx.runQuery(internal.patterns.analyze, {
      userId: ctx.userId,
      query: args.query,
      timeframe: args.timeframe
    });
    
    return {
      insights: patterns.insights,
      examples: patterns.examples,
      recommendation: patterns.recommendation
    };
  }
});

export const findSimilarDays = createTool({
  description: "Find days similar to today based on eating patterns",
  args: z.object({
    targetCalories: z.number().optional(),
    mealPattern: z.string().optional()
  }),
  handler: async (ctx, args): Promise<object> => {
    // Use vector search to find similar days
    const embedding = await generateEmbedding(
      `${args.targetCalories || ""} ${args.mealPattern || ""}`
    );
    
    const similarDays = await ctx.vectorSearch("dailySummaries", {
      vector: embedding,
      filter: q => q.eq("userId", ctx.userId),
      limit: 10
    });
    
    return analyzeSimilarDays(similarDays);
  }
});
```

## 4. Plateau Detection & Intervention ðŸ“Š [PRIORITY: MEDIUM]

### Description
Automatically detect weight loss plateaus and suggest interventions.

### Requirements
- Detect 2+ weeks of no progress
- Analyze adherence during plateau
- Suggest diet breaks or refeed days
- Track intervention success

### Implementation Steps

#### 4.1 Add Schema
```typescript
plateauDetections: defineTable({
  userId: v.string(),
  detectedAt: v.number(),
  duration: v.number(), // weeks
  avgCalories: v.number(),
  avgWeight: v.number(),
  adherenceScore: v.number(),
  intervention: v.optional(v.object({
    type: v.enum(["diet_break", "refeed", "calorie_cycling", "macro_shift"]),
    suggestedAt: v.number(),
    accepted: v.boolean(),
    outcome: v.optional(v.string())
  }))
}).index("by_user", ["userId", "detectedAt"])
```

#### 4.2 Detection Logic
```javascript
// Run weekly
export const detectPlateau = internalMutation({
  args: { userId: v.string() },
  handler: async (ctx, { userId }) => {
    const recentWeights = await getRecentWeights(ctx, userId, 21); // 3 weeks
    
    if (recentWeights.length < 10) return;
    
    const weeklyAverages = calculateWeeklyAverages(recentWeights);
    const change = Math.abs(weeklyAverages[0] - weeklyAverages[2]);
    
    if (change < 0.2) { // Less than 200g change over 3 weeks
      // Check if already detected
      const existing = await ctx.db.query("plateauDetections")
        .withIndex("by_user", q => q.eq("userId", userId))
        .order("desc")
        .first();
      
      if (!existing || existing.detectedAt < Date.now() - 7 * 24 * 60 * 60 * 1000) {
        await ctx.db.insert("plateauDetections", {
          userId,
          detectedAt: Date.now(),
          duration: existing ? existing.duration + 1 : 1,
          avgCalories: await getAvgCalories(ctx, userId, 21),
          avgWeight: weeklyAverages[1],
          adherenceScore: await calculateAdherence(ctx, userId, 21)
        });
        
        // Notify Bob to suggest intervention
        await ctx.db.insert("systemMessages", {
          userId,
          type: "plateau_detected",
          message: "User has been in plateau for 3 weeks"
        });
      }
    }
  }
});
```

## 5. Daily Summary & Insights ðŸ“ˆ [PRIORITY: LOW]

### Description
Generate daily summaries with embeddings for pattern matching.

### Implementation Steps

#### 5.1 Add Schema
```typescript
dailySummaries: defineTable({
  userId: v.string(),
  date: v.string(), // YYYY-MM-DD
  summary: v.object({
    totalCalories: v.number(),
    macros: v.object({
      protein: v.number(),
      carbs: v.number(),
      fat: v.number()
    }),
    meals: v.array(v.string()), // meal descriptions
    weight: v.optional(v.number()),
    mood: v.optional(v.string()),
    exercise: v.optional(v.string())
  }),
  embedding: v.optional(v.array(v.number())),
  insights: v.optional(v.array(v.string()))
}).index("by_user_date", ["userId", "date"])
```

## 6. Smart Reminders ðŸ”” [PRIORITY: LOW]

### Description
Intelligent reminders based on user patterns.

### Implementation Steps

#### 6.1 Add Schema
```typescript
reminderSettings: defineTable({
  userId: v.string(),
  reminders: v.array(v.object({
    type: v.enum(["weight", "meal", "water", "summary"]),
    time: v.number(), // Hour in user's timezone
    days: v.array(v.number()), // 0-6 for days of week
    enabled: v.boolean(),
    message: v.optional(v.string())
  })),
  timezone: v.string(),
  channel: v.enum(["in_app", "email", "sms"])
})
```

## Implementation Priority Order

1. **Week 1-2**: Photo Analysis
   - Most user-facing feature
   - High value for user experience
   - Clear monetization driver

2. **Week 2-3**: Metabolic Calibration
   - Core differentiator
   - Runs in background
   - Creates "wow" moments

3. **Week 3-4**: Pattern Recognition
   - Leverages existing embeddings
   - Provides unique insights
   - Increases retention

4. **Week 4-5**: Plateau Detection
   - Solves real user pain point
   - Automated intervention

5. **Week 5-6**: Polish & Reminders
   - Daily summaries
   - Smart reminders
   - UI improvements

## Testing Strategy

For each feature:
1. Unit tests for core logic
2. Integration tests with Convex
3. Manual testing of Bob's responses
4. Beta test with small user group
5. Monitor usage and errors
6. Iterate based on feedback

## Success Metrics

- Photo analysis usage rate
- Calibration accuracy (predicted vs actual weight change)
- Pattern insights engagement
- Plateau intervention success rate
- Overall user retention improvement